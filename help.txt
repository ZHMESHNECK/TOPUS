https://proproprogs.ru/django
https://django.fun/docs/django/ru/4.0/ref/models/fields/ - типы полей

django-admin startproject <site name>
cd <site name>
python manage.py runserver
создаём приложение python manage.py startapp <name>
admin.py - админ панель на сайте
apps.py - конфигурация текущего приложения
models.py - хранения orm моделей
test.py - для тестов
views.py - для хранения представлений (контролеров)
test > test > settings.py > INSTALLED_APPS  и добавляем наше приложение (tanks.apps.TanksConfig)
дальше в views.py пишем функию или клас
urls.py добавляем путь (path('tanks/', index)) + импорт индекса
#tanks/ - добавляется к домену
<h1> - заголовок первого уровня
создал папку urls в приложении

path('cats/<slug:tank_class>/', categories)
str - не пустая строка, исключая /
int - любое положительное число включая 0
slug - латиница ASCII таблицы, + символы дефиса и подчеркивания
uuid - цифры, малые латинские символы ASCII, дефис
path - не пустая строка, включая /

лучшее использовать slug - так визуально понятнее

Обработка исключений при запросах к серверу DEBUG = False !
handler500 - ошибка сервера
handler403 - доступ запрещен
handler400 - невозможно обработать запрос

Создание 301 и 302 редиректов
301 страница перемещена на другой адрес
302 страница временно перемещена на другой адрес

стpоим модель в models.py 
- id (int,primary key) - не пишем (он автоматом)
- title (var)
- slug
- content (text)
- photo (image)
- time_create (date)
- time_update (date)
- is_published (bool)

добавляем в settings 
MEDIA_ROOT = os.path.join(BASE_DIR,'media') ссылается на папку медиа в тек. каталоге
MEDIA_URL = '/media/' добавляет media в url

делаем миграцию в консоле (вроде нужно после добавление моделей) (созаёт таблицы)
посмотреть на sql запрос который будет выполнен -  python manage.py sqlmigrate tanks 0001

делаем миграцию (созадём таблицу в бд) - python manage.py migrate

Изменять таблицы - CRUD
чтоб менять файлы в бд - python manage.py shell 
импортируем нужную модель from tanks.models import Tank
создаём новую запись
Tank(title='T-44-100',content='soviet tank') (django добавляет всё в конце)
что б вручную добавить - w1 = Tank(title='T-44-100',content='soviet tank')
sudo !! == _
w1.save()
w1.pk - это как id только всегда доступен и в django работают через него
t = Tank.objects.get(pk=2)

Tank.objects.all() - посмотреть сколько есть объектов
что б выводить заоголов записи, а не объект (в конце models.py)- def __str__(self):
                                                    return self.title
перезапускаем консоль
импортируем Tank с tanks.models
чтоб работат со списком - присваиваем его
отсортировать по ид > or < - pk__gte=2 больше или == 2
                             pk__lte=2 меньше или == 2
указать сортировку Tank.objects.filter(pk__lte=2).order_by('title')

Создаём шаблон страницы

в views вместо http -> render
+ создаём папку templates и в ней tanks

в url тоже добавляем ссылку "path('about/', about)"

чтоб присвоить любое имя вкладке <title>{{ title }}</title> берём имя с views (3-й аргумент)
{'title': 'Главная страница'}

отобразить список на сайте
B views menu = [О сайте, добавить статью, обратная связь,войти]
 + в словарь 'menu':menu 

в body добавляем цыкл
<ul>
{% for i in menu %}
<li>{{i}}</li>
{% endfor %}
</ul>

Нужно создать базовый шаблон , что б не повторяться

дальше меняем все html -> расширяем {% extends 'tanks/base.html' %}

для чтения бд на сайт импортируем  from .models import * (views)
posts = Tank.objects.all() - выбираем все записи с бд + 'posts': post

чтоб статик норм работал нужжно в настройках добавить STATIC_URL,STATIC_ROOT, STATICFILES_DIRS
добавляем статик файл, а в нём css , images , js
В base.html вверху добавляем {% load static %} - подключаем внешние файлы
файл оформелние подключается в head link type = "text/css" href="{% static 'tanks/css/styles.css' %}"
в шаблонах тоже подключаем статик и делаем оформелние
добавляем фильтры 

формирования url
/ - плохо
{% url 'home' %} нажимаешь на логотип - перекидывает на главную
чтоб было красиво, все словари пишем не в строчку, а передаём ссылку на него
в конце рендера указывает эту ссылку context = {name of slovar}
добавляем ссылку на читать пост в urls.py (лучше делать slug ссылки, для этого пишем def в классе)
дальше в индекс (p это ссылка на экземпляр класса)
дописываем в модель функию которая стоить красивый маршрут к записи
и в indexe  вызываем её {{ p.get_absolute_url }}
для категорий делаем связь много у 1 

Создаём доп поле в главном классе foreighnkey
делаем новую миграцию, но так как таблици ещё нет, можно указать NULL=True чтобы таблица заполнилась нулями
python manage.py makemigrations потом python manage.py migrate - лучше так не делать, а продумывать заранее
заходим в оболочку from tanks.models import * потом создаём категории Category.objects.create(name='Лёгкие танки')

добавляем в новый класс функ красивого вывода потом в urls новый маршрут
в функию index добавляем cats = Category.objects.all()  и в словарь 'cats':cats и
'cat_selected': 0 для отображения всех категорий
в show_category добавляем всё то что в index только .filter(cat_id=cat_id)
cat_selected : cat_id
чтоб добавить время создания поста и категорию в index

Работа с админ панелью
регаемся python manage.py createsuperuser  (ZHMESH)
регистрируем модели в admin.py from .models import *
admin.site.register(Tank)

чтоб изменить имя класа добавляем в класс , класс meta \n verbose_name = 
чтоб убрать s verbose_name_plural = 
сортировка по временни создания, потом по названию ordering = ['time_create','title']  обратная сортировка '-'
на сайт тоже влияет
чтоб сменить имя категории в админке - в apps verbose_name

доп. поля в админки - в admin.py class TankAdmin(admin.ModelAdmin):
    list_display - список полей которые будут видны на панельке
    list_display_links = ('id','title') - для перехода на статью
    search_fields - по каким полям делать поиск
также указываем его в admin.site.register 2-м параметром
сменить названия колонок, в models.py дописываем везде verbose_name

делаем в index.html проверку на фото, если есть 
делаем робочие кнопки is_published, в admin добавляем list_editable('is_published')
там же можно добавить фильтр list_filter = ('is_published','time_create')

ТЕГИ (редко)
создаём папку templatetags а в нём инит и файл tags.py
в нём импорт from django import template , from tanks.models import *
регистрируем собственные теги register = template.Library()
пишем функция для работы тега def get_categories():
    return Category.objects.all()

дальше связывем функию с тегом - декоратор @register.simple_tag()
загружаем теги в базовый шаблон {% load tank_tags %} и вставляем {% get_categories %} где нужно запустить
чтоб перебрать тег нужно занести его в переменную {% get_categories as categories %}
теперь категории берутся из тега, а не через шаблон
убираем в views   cats = Category.objects.all() и в show_category

включающий тег формирует html страницу
переносим категории (слева) в list_categories , а в base {% show_categories %} , {% get_categories as ... %} тоже
передаём параметры тегам filter = None
в base {% get_categories filter=1 %} - передача параметров тегу (или просто параметр) (просто проверка)

{% show_categories '-name' cat_selected %} - фильтрация по имени

Добавление СЛАГОВ в url
во views - show_post, делаем шаблон html
для слага дописываем во все модели slug = models.SlugField
чтоб изменить таблицу нужно удалить все миграции 
делаем автоввод url , в админке, в моделях, пишем атрибут prepopulated_fields = {'slug':('name',)}
в urls, show_post, меняем int на slug:post_slug,  во views меняем post_id на slug_id
ищем не по pk, а по slug (slug=post_slug)
в моделях в функции get_absolute_url меняем kwargs={'post_slug':self.slug}

Формы не связанные с моделями (можно проще 212)
создаём файл forms.py и импортируем from django import forms и с моделей *
и пишем класс AddPostForm(forms.Form) -> те поля которые будут на форме
    title = forms.CharField(max_length=250)
    slug = forms.SlugField(max_length=250)
    content = forms.CharField(widget=forms.Textarea(attrs={'cols':60, 'rows':10}))
    is_published = forms.BooleanField()
    cat = forms.ModelChoiceField(queryset=Category.objects.all())

в views добавляем если юзер впервый раз ->form = AddPostForm() else:
if request.method == 'POST':
    form = AddPostForm(request.POST)
    if form.is_valid():
        print(form.cleaned_data)
в html пишем тег form. {{ form.as_p }} - генерация формы
перевод на русский - label в forms
Для красивого вывода вместо form.as_p
<p><label ... >
делаем это в цыкле {% for f in form %}
    <p><label class='form-label' for="{{ f.id_for_label }}">{{ f.label }}:</label>{{ f }}</p>
    <div class="form-error">{{ f.errors }}</div>

а чтобы дать каждому свой стиль, мы в forms в атрибутах дописываем widget = forms.TextInput(attrs={'class':
'form-input'})

Связываем формы с моделями 
в forms делаем клас наследыванный от forms.ModelForm , а в нём класс мета
рекомендуют добавлять поля вручную fields = ['title','slug'...]
widgets - настроит поля  widgets = {'title':forms.TextInput(attrs={'class':'form-input'})}
чтоб изначально категория была не выбрана - пишем конструктор
def __init__(self,*args,**kwargs):
    super().__init__(*args,**kwargs)
    self.fields['cat'].empty_label = 'Категория не выбрана'

когда форма связанна с моделью, то убираем try и пишем form.save()
во views func addpage -> form = AddPostForm(2-й аргумент request.FILES) (для передачи файлов на сервер)
также в addpage в form enctype="multipart/form-data"
можем сделать свою проверку для формы  
в forms пишем def clean_(имя поля)(self):
должна возвращать raise ValidationError('')

Функии представлений для простых сайтов, есть классы представлений(ООП чаще всего)
меняем index на listview (класс создающий список чего либо) т.е пишем class TankHome(ListView):
    model = Tank

в urls меняем index на TankHome.as_view() (т.е вызывает эту функию)
чтоб django искать именно наш html дописываем template_name = 'tanks/index.html'
в index меняем posts на object_list, чтоб этого не делать дописываем context_object_name = 'posts'
указать название вкладки - extra_context = {'title':'Главная страница'} (можно ниже в функ)
что б добавить динамический и статичный контекст пишем функию def get_context_data(self,*,object_list=None,
**kwargs)

получаем готовый контекст для index 
context = super().get_context_data(**kwargs)
context['menu'] = menu
return context
чтоб была выбрана категория - context['cat_selected'] = 0

Дальше отображаем публикации которые отмечены
пишем метод 
    def get_queryset(self):
        return Tank.objects.filter(is_published = True)
также для всех функций 
В TankCategory делаем фильтр по указаному слагу
cat__slug - cat это в оригинальной моделе, __slug ссылаемся на поле слаг в записи cat
если стриницы нет - allow_empty = False
slug_url_kwarg = 'post_slug' url по слагу
context_object_name = 'post'

Делаем mixin - создаём utils.py
переносим туда меню и пишем class DataMixin:

в base заменяем {% show_categories 'name' cat_selected %} на 
for c in cats
if c.pk == cat_selected ...
дальше добавляем DataMixin в классы, убираем лишние строчки и пишем c_def = self.get_user_context(title='Главная страница')
возвращаем общий словарь context и c_def т.е -> return context | c_def
context формируется на базовом классе ListView, c_def - DataMixin
Чтоб пост добавляли только авторизованые юзеры -> from ... import LoginRequiredMixin
также можно написать функию и к ней декоратор @login_required
можно вообще убрать кнопку для неавторизованих , пишем копируем меню в ориг.миксине
user_menu = menu.copy()
if not self.request.user.is_authenticated:
    user_menu.pop(1)
также если в рубрике нет постов, его можно не отображать cats = Category.objects.annotate(Count('tank')) и в base

Пагинация
В TankHome paginate_by = 3
для функий contact_list = Tank.objects.all()
paginator = Paginator(contact_list, 3)
page_number = request.GET.get('page')
page_obj = paginator.get_page(page_number)

для class - в base после блока контент <nav class=...>
    <ul>{% for p in paginator.page_range %}
        {% if page_obj.number == p %} - если номер стр совпадает с кнопкой, то отображаем как текст
добавляем в категорию в mixin добавляем paginate_by = 3 перед функцией
{% elif p >= page_obj.number|add:-2 and p <= page_obj.number|add:2 %} +- 2 страницы навигации

Пользователи
выносим li class=last за цикл и меняем её на ссылку url 'register' | a url 'login'
в utils убираем логин в меню
пишем новый класс и html, в классе пишем контекст def get_context_data
в html form method потому что в случае ошибки, обработчик будет перенаправлять туда же
для улучшения формы, в forms создаём свой класс 
для просмотра названий полей, в админке просмотр кода элемента

Авторизация
пишем класс авторизации во view + иморты + пишем html 
связываем класс представления с маршрутом и пишем функию get_success_url для перенаправления
ещё можно вместо функии , в настройках LOGIN_REDIRECT_URL = '/'
дальше для улучшения отображения, идём в form и пишем форму
если юзер авторизован то убираем кнопки сверху base.html, пишем до условие
{% if request.user.is_authenticated %}
добавляем новый путь logout и пишем функию обработчик logout_user в views
Автоматически авторизовываем юзера при успешной регистрации
В RegisterUser пишем функию form_valid

Оптимизация Django Debug Toolbar
качаем pip, в настройках добавляем приложение debuf_toolbar
"debug_toolbar.middleware.DebugToolbarMiddleware" - middleware 
в конце internal_ips, в оригинальном url path ...  + там же и импорт debug_toolbar
 import mimetypes
    mimetypes.add_type("application/javascript", ".js", True)

в toolbare - sql -duplicated - плохо
сейчас для каждого танка выполняется sql запрос для его категории
нужен метод .select_related('cat') -> foreighnkey во views в TankHome and TankCategory
prefetch_related -> ManyToMany
в TankCategory ещё с = Category.objects.get(slug=self.kwargs['cat_slug'])

КЭШ в файловой системе (подключаем в самом конце создания сайта)
добавляем в настройки CACHES и путь к папке 'LOCATION': os.path.join(BASE_DIR, 'testsite_cache')
кэширования на уровне представлений, можно на уровне функций, но  у нас классы
импорт в urls cache_page, потом в первом пути добавляем cache_page(60*15) (15 минут)
кешировать чаты или коменты которые всё время появляются нельзя

ещё можно кэширование на уровне шаблонов, в base в сайд бар {% load cache %} потом {% cache 60 sidebar %} (... время название)
в конце {% endcache %}

API низкоуровнего кеширования
cache.set() - сохранение произвольных данных в кэш по ключу
cache.гет() - выбор данных  из кэша
cache.адд() - заносит новое значение в кэш, если его там нет
cache.гет_ор_сет() - извлекает данные из кэша, если их нет, то заносит
cache.делете() - удаление из кэша по ключу
cache.клеар() - очистка кэша
в DataMixin кэшируем cats, cats = cache.get('cats')

CAPTCHA и обратная связь

пишем класс class ContactFormView(DataMixin, FormView):
в forms.py ContactForm дальше в urls + django captcha (делаем как в документации)
в forms импорт CaptchaField + в конец ContactForm capatcha = CaptchaField()

Настройка admin panel

в корне папки сайта создаём папку templates, в нём папку admin -> base_site.html
дальше в настройках в TEMPLATES -> DIRS:[os.path.join(BASE_DIR,'templates')],
в новом base_site.html
{% load static %}
{% block extrastyle %}
<link rel="stylesheet" href="{% static 'css/admin.css' %}">
{% endblock %}

чтоб сменить титулку на админке, то лучше менять всё это через admin.py 
admin.site.site_title = 'Админ-панель сайта о тунчесах'
admin.site.site_header = 'Админ-панель сайта о тунчесах'
чтоб вместо пути біла картинка в admin пишем def get_html_photo(self,object):
    if object.photo:
        return mark_safe(f"<img src='{object.photo.url}' width=50>")
и вместо photo в list_display -> get_html_photo
чтоб отображать фото при редактировании
fields = ('title','slug','cat','content','photo','get_html_photo','is_published')
